########################################################################################
# Imports
########################################################################################

import sys
import cv2 as cv
import numpy as np

# If this file is nested inside a folder in the labs folder, the relative path should
# be [1, ../../library] instead.
sys.path.insert(1, "../../library")
import racecar_core
import racecar_utils as rc_utils

########################################################################################
# Global variables
########################################################################################

rc = racecar_core.create_racecar()

# >> Constants
# The smallest contour we will recognize as a valid contour
MIN_CONTOUR_AREA_LINE = 50
MIN_CONTOUR_AREA_WALL = 10000

# A crop window for the floor directly in front of the car
CROP_FLOOR = ((360, 0), (rc.camera.get_height(), rc.camera.get_width()))

# TODO Part 1: Determine the HSV color threshold pairs for GREEN and RED
# Colors, stored as a pair (hsv_min, hsv_max) Hint: Lab E!
BLUE = ((90, 100, 100), (120, 255, 255))  # The HSV range for the color blue
GREEN = ((60, 50, 50), (80, 255, 255))  # The HSV range for the color green
RED1 = ((0, 50, 50), (10, 255, 255))  # The HSV range for the color red
RED2 = ((165, 50, 50), (179, 255, 255))
ORANGE = ((20, 250, 250), (30, 255, 255))
PURPLE = ((155, 100, 100), (160, 255, 255))

# Color priority: Red >> Green >> Blue
COLOR_PRIORITY = (RED1, RED2, GREEN, BLUE)

# >> Variables
speed = 0.0  # The current speed of the car
angle = 0.0  # The current angle of the car's wheels
contour_center = None  # The (pixel row, pixel column) of contour
contour_area = 0  # The area of contour


########################################################################################
# Functions
########################################################################################

# [FUNCTION] Finds contours in the current color image and uses them to update 
# contour_center and contour_area
def update_contour():
    global contour_center
    global contour_area

    image = rc.camera.get_color_image()

    if image is None:
        contour_center = None
        contour_area = 0
    else:
        # Crop the image to the floor directly in front of the car
        image = rc_utils.crop(image, CROP_FLOOR[0], CROP_FLOOR[1])

        # TODO Part 2: Search for line colors, and update the global variables
        # contour_center and contour_area with the largest contour found
        contours_blue = rc_utils.find_contours(image, BLUE[0], BLUE[1])
        contour_blue = rc_utils.get_largest_contour(contours_blue, MIN_CONTOUR_AREA_LINE)

        contours_green = rc_utils.find_contours(image, GREEN[0], GREEN[1])
        contour_green = rc_utils.get_largest_contour(contours_green, MIN_CONTOUR_AREA_LINE)

        contours_red1 = rc_utils.find_contours(image, RED1[0], RED1[1])
        contour_red1 = rc_utils.get_largest_contour(contours_red1, MIN_CONTOUR_AREA_LINE)

        contours_red2 = rc_utils.find_contours(image, RED2[0], RED2[1])
        contour_red2 = rc_utils.get_largest_contour(contours_red2, MIN_CONTOUR_AREA_LINE)

        if contour_red1 is not None:
            contour = contour_red1
        elif contour_red2 is not None:
            contour = contour_red2
        elif contour_green is not None:
            contour = contour_green
        elif contour_blue is not None:
            contour = contour_blue
        else:
            contour = None

        if contour is not None:
            contour_center = rc_utils.get_contour_center(contour)
            contour_area = rc_utils.get_contour_area(contour)
            #rc_utils.draw_contour(image, contour)
            #rc_utils.draw_circle(image, contour_center)
        # Display the image to the screen
        #rc.display.show_color_image(image)

def update_contour_walls():
    global angle
    image = rc.camera.get_color_image()

    if image is not None:
        image = rc_utils.crop(image, (120, 0), (rc.camera.get_height(), rc.camera.get_width()))

        contours_purple = rc_utils.find_contours(image, PURPLE[0], PURPLE[1])
        contour_purple = rc_utils.get_largest_contour(contours_purple, MIN_CONTOUR_AREA_WALL)
        contours_orange = rc_utils.find_contours(image, ORANGE[0], ORANGE[1])
        contour_orange = rc_utils.get_largest_contour(contours_orange, MIN_CONTOUR_AREA_WALL)
        #print("contours_orange: ", contours_orange)
        #print("contour_orange", contour_orange)

        rc_utils.draw_contour(image, contour_purple)
        rc_utils.draw_contour(image, contour_orange)

        rc.display.show_color_image(image)
    
    setpoint = rc.camera.get_width() // 2

    if contour_purple is not None:
        contour_center_purple = rc_utils.get_contour_center(contour_purple)
        print(contour_center_purple[1])
        if -0.2 <= angle <= 0.2:
            if (setpoint - 10) <= contour_center_purple[1] <= (setpoint + 10):
               return True 
        else:
            if (setpoint - 30) <= contour_center_purple[1] <= (setpoint + 30):
               return True 
    if contour_orange is not None:
        contour_center_orange = rc_utils.get_contour_center(contour_orange)
        print(contour_center_orange[1])
        if -0.2 <= angle <= 0.2:
            if (setpoint - 10) <= contour_center_orange[1] <= (setpoint + 10):
               return True 
        else:
            if (setpoint - 30) <= contour_center_orange[1] <= (setpoint + 30):
               return True
    return False

# [FUNCTION] The start function is run once every time the start button is pressed
def start():
    global speed
    global angle

    # Initialize variables
    speed = 0
    angle = 0

    # Set initial driving speed and angle
    rc.drive.set_speed_angle(speed, angle)

    # Set update_slow to refresh every half second
    rc.set_update_slow_time(0.5)

    # Print start message
    print(
        ">> Lab 2A - Color Image Line Following\n"
        "\n"
        "Controls:\n"
        "   Right trigger = accelerate forward\n"
        "   Left trigger = accelerate backward\n"
        "   A button = print current speed and angle\n"
        "   B button = print contour center and area"
    )

# [FUNCTION] After start() is run, this function is run once every frame (ideally at
# 60 frames per second or slower depending on processing speed) until the back button
# is pressed  
def update():
    """
    After start() is run, this function is run every frame until the back button
    is pressed
    """
    global speed
    global angle

    # Search for contours in the current color image
    update_contour()

    # TODO Part 3: Determine the angle that the RACECAR should receive based on the current 
    # position of the center of line contour on the screen. Hint: The RACECAR should drive in
    # a direction that moves the line back to the center of the screen.

    # Choose an angle based on contour_center
    # If we could not find a contour, keep the previous angle
    if contour_center is not None:
        setpoint = rc.camera.get_width() // 2
        error = setpoint - contour_center[1]
        kp = -0.003125
        angle = kp * error

        angle = rc_utils.clamp(angle, -1, 1)

    # Use the triggers to control the car's speed
    speed = 1

    walls = update_contour_walls()
    if walls:
        #print("Stop")
        rc.drive.set_speed_angle(0, 0)
    else:
        #print("Go")
        rc.drive.set_speed_angle(speed, angle)

    # Print the current speed and angle when the A button is held down
    if rc.controller.is_down(rc.controller.Button.A):
        print("Speed:", speed, "Angle:", angle)

    # Print the center and area of the largest contour when B is held down
    if rc.controller.is_down(rc.controller.Button.B):
        if contour_center is None:
            print("No contour found")
        else:
            print("Center:", contour_center, "Area:", contour_area)

# [FUNCTION] update_slow() is similar to update() but is called once per second by
# default. It is especially useful for printing debug messages, since printing a 
# message every frame in update is computationally expensive and creates clutter
def update_slow():
    """
    After start() is run, this function is run at a constant rate that is slower
    than update().  By default, update_slow() is run once per second
    """
    # Print a line of ascii text denoting the contour area and x-position
    if rc.camera.get_color_image() is None:
        # If no image is found, print all X's and don't display an image
        print("X" * 10 + " (No image) " + "X" * 10)
    else:
        # If an image is found but no contour is found, print all dashes
        if contour_center is None:
            print("-" * 32 + " : area = " + str(contour_area))

        # Otherwise, print a line of dashes with a | indicating the contour x-position
        else:
            s = ["-"] * 32
            s[int(contour_center[1] / 20)] = "|"
            print("".join(s) + " : area = " + str(contour_area))


########################################################################################
# DO NOT MODIFY: Register start and update and begin execution
########################################################################################

if __name__ == "__main__":
    rc.set_start_update(start, update, update_slow)
    rc.go()